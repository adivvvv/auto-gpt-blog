#!/usr/bin/env php
<?php declare(strict_types=1);
// bin/article-generate
// robust generator with validation + retries for a single article from the feed service.
use App\FeedClient;
use App\Util;

require __DIR__ . '/../public/bootstrap.php';

// --- perms config ---
umask(0002); // group-writable by default
$WEB_GROUP = getenv('WEB_GROUP') ?: 'www-data';
$ensurePerms = function(string $path, bool $isDir=false, bool $isPostsJson=false) use ($WEB_GROUP): void {
    @chgrp($path, $WEB_GROUP);
    if ($isDir) {
        @chmod($path, 02775); // setgid dir; g+rwX
    } else {
        @chmod($path, $isPostsJson ? 0775 : 0664);
    }
};

const MIN_BODY_CHARS = 200;
const MAX_RETRIES     = 5;

$cfg   = Util::loadConfig();
$lang  = (string)($cfg['lang'] ?? 'en');
$base  = realpath(__DIR__ . '/..') ?: dirname(__DIR__);
$postsDir  = $base . '/data/posts';
$indexFile = $base . '/data/posts.json';
@mkdir($postsDir, 02775, true);
$ensurePerms(dirname($postsDir), true);
$ensurePerms($postsDir, true);
$ensurePerms(dirname($indexFile), true);

/** Character length (Unicode aware if mbstring present). */
$strlen = function(string $s): int {
    if (function_exists('mb_strlen')) return (int)mb_strlen($s, 'UTF-8');
    return strlen($s); // bytes, but still a safe fallback
};

/**
 * Transliterate to ASCII for slugs (languages: en,de,fr,it,es,sv,fi,nl,pl,cs).
 * Then canonical slugify -> "a-z0-9-" only, collapsed, trimmed, lowercase.
 */
$shouldTransliterate = function(string $lang): bool {
    return in_array($lang, ['en','de','fr','it','es','sv','fi','nl','pl','cs'], true);
};
$transliterate = function(string $s, string $lang) use ($shouldTransliterate): string {
    if ($s === '' || !$shouldTransliterate($lang)) return $s;

    // Common Latin diacritics across those languages
    $map = [
        // Polish
        'ą'=>'a','ć'=>'c','ę'=>'e','ł'=>'l','ń'=>'n','ó'=>'o','ś'=>'s','ź'=>'z','ż'=>'z',
        'Ą'=>'A','Ć'=>'C','Ę'=>'E','Ł'=>'L','Ń'=>'N','Ó'=>'O','Ś'=>'S','Ź'=>'Z','Ż'=>'Z',
        // German
        'ä'=>'a','ö'=>'o','ü'=>'u','ß'=>'ss','Ä'=>'A','Ö'=>'O','Ü'=>'U',
        // French
        'à'=>'a','â'=>'a','ä'=>'a','ç'=>'c','é'=>'e','è'=>'e','ê'=>'e','ë'=>'e',
        'î'=>'i','ï'=>'i','ô'=>'o','ö'=>'o','ù'=>'u','û'=>'u','ü'=>'u','ÿ'=>'y',
        'À'=>'A','Â'=>'A','Ä'=>'A','Ç'=>'C','É'=>'E','È'=>'E','Ê'=>'E','Ë'=>'E',
        'Î'=>'I','Ï'=>'I','Ô'=>'O','Ö'=>'O','Ù'=>'U','Û'=>'U','Ü'=>'U','Ÿ'=>'Y',
        'œ'=>'oe','Œ'=>'OE','æ'=>'ae','Æ'=>'AE',
        // Spanish
        'á'=>'a','é'=>'e','í'=>'i','ó'=>'o','ú'=>'u','ñ'=>'n','ü'=>'u',
        'Á'=>'A','É'=>'E','Í'=>'I','Ó'=>'O','Ú'=>'U','Ñ'=>'N','Ü'=>'U',
        // Swedish / Finnish
        'å'=>'a','Å'=>'A',
        // Czech
        'á'=>'a','č'=>'c','ď'=>'d','é'=>'e','ě'=>'e','í'=>'i','ň'=>'n','ó'=>'o',
        'ř'=>'r','š'=>'s','ť'=>'t','ú'=>'u','ů'=>'u','ý'=>'y','ž'=>'z',
        'Á'=>'A','Č'=>'C','Ď'=>'D','É'=>'E','Ě'=>'E','Í'=>'I','Ň'=>'N','Ó'=>'O',
        'Ř'=>'R','Š'=>'S','Ť'=>'T','Ú'=>'U','Ů'=>'U','Ý'=>'Y','Ž'=>'Z',
        // Misc common
        'ø'=>'o','Ø'=>'O','đ'=>'d','Đ'=>'D','ħ'=>'h','Ħ'=>'H'
    ];
    $s = strtr($s, $map);

    // Best-effort final pass if iconv available
    if (function_exists('iconv')) {
        $t = @iconv('UTF-8', 'ASCII//TRANSLIT//IGNORE', $s);
        if (is_string($t) && $t !== '') $s = $t;
    }
    return $s;
};
$slugifyAscii = function(string $s, string $lang) use ($transliterate): string {
    $s = $transliterate($s, $lang);
    $s = mb_strtolower($s, 'UTF-8');
    $s = preg_replace('/[^a-z0-9]+/', '-', $s) ?? '';
    $s = trim($s, '-');
    $s = preg_replace('/-+/', '-', $s) ?? '';
    return $s;
};

/** Build post array from raw API response. */
$buildPost = function(array $resp) use ($strlen): array {
    $title   = (string)($resp['title'] ?? $resp['article']['title'] ?? '');
    $slugIn  = (string)($resp['slug']  ?? '');
    $slug    = $slugIn !== '' ? $slugIn : ($title !== '' ? Util::slugify($title) : '');
    $summary = (string)($resp['summary'] ?? '');
    $tags    = array_values(array_filter((array)($resp['tags'] ?? [])));
    $refs    = (array)($resp['references'] ?? []);
    $faqs    = (array)($resp['article']['faqs'] ?? $resp['faqs'] ?? []);

    // Derive paragraphs from the structured 'article' shape if present.
    $paragraphs = [];
    foreach ((array)($resp['article']['content'] ?? []) as $block) {
        $p = (string)($block['paragraph'] ?? '');
        if ($p !== '') $paragraphs[] = $p;
    }

    // Fallbacks if the provider already includes body fields
    $body_md = trim(implode("\n\n", $paragraphs));
    if ($body_md === '') {
        $body_md = trim((string)($resp['body_markdown'] ?? ''));
        if ($body_md === '' && !empty($resp['body'])) {
            // Strip tags for a markdown-ish fallback length check later
            $body_md = trim(strip_tags((string)$resp['body']));
        }
    }

    // HTML from paragraphs (preferred) else use provided HTML
    $esc = static fn(string $s): string => htmlspecialchars($s, ENT_QUOTES | ENT_SUBSTITUTE, 'UTF-8');
    $body_html = '';
    if (!empty($paragraphs)) {
        $paras_html = array_map(fn($p) => '<p>'.$esc($p).'</p>', $paragraphs);
        $body_html  = implode("\n", $paras_html);
    } elseif (!empty($resp['body'])) {
        $body_html = (string)$resp['body'];
    }

    // PMIDs for references section
    $pmids = [];
    foreach ($refs as $r) {
        $pm = (string)($r['pmid'] ?? '');
        if ($pm !== '') $pmids[] = $pm;
    }

    return [
        'title'         => $title,
        'slug'          => $slug,
        'summary'       => $summary,
        'tags'          => $tags,
        'published_at'  => date('Y-m-d'),
        'body_markdown' => $body_md,
        'body'          => $body_html,
        'faqs'          => $faqs,
        'references'    => $refs,
        'pmids'         => $pmids,
    ];
};

/** Validate required fields. */
$isValid = function(array $post) use ($strlen): bool {
    if ($post['title'] === '' || $post['slug'] === '') return false;
    // body can be either markdown or html; check combined minimum length
    $len = $strlen(trim($post['body_markdown'] ?? ''));
    if ($len < MIN_BODY_CHARS) {
        $len = $strlen(trim(strip_tags((string)($post['body'] ?? ''))));
    }
    return $len >= MIN_BODY_CHARS;
};

/** Ensure slug uniqueness by suffixing -2, -3, ... */
$uniqueSlug = function(string $slug) use ($postsDir): string {
    $base = $slug !== '' ? $slug : 'post';
    $s = $base;
    $i = 2;
    while (is_file($postsDir . '/' . $s . '.json')) {
        $s = $base . '-' . $i;
        $i++;
        if ($i > 5000) { // sanity
            throw new RuntimeException('Unable to allocate unique slug.');
        }
    }
    return $s;
};

/** Atomic JSON write. */
$atomicWrite = function(string $path, string $json): void {
    $dir = dirname($path);
    $tmp = tempnam($dir, 'post_');
    if ($tmp === false) throw new RuntimeException('tempnam failed for ' . $dir);
    file_put_contents($tmp, $json, LOCK_EX); // lock while writing
    if (!@rename($tmp, $path)) {
        @unlink($tmp);
        throw new RuntimeException('rename() failed writing ' . $path);
    }
};

$client = new FeedClient((string)$cfg['feed_base_url'], (string)$cfg['feed_api_key']);

$attempt = 0;
$lastError = '';
$post = null;

while ($attempt < MAX_RETRIES) {
    $attempt++;
    fwrite(STDERR, "[article-generate] attempt {$attempt}…\n");
    try {
        $resp = $client->generateArticle($lang);
    } catch (\Throwable $e) {
        $lastError = 'API error: ' . $e->getMessage();
        fwrite(STDERR, $lastError . "\n");
        continue;
    }

    $candidate = $buildPost($resp);
    if ($isValid($candidate)) {
        $post = $candidate;
        break;
    } else {
        $bodyLen = $strlen(trim($candidate['body_markdown'] ?: strip_tags($candidate['body'] ?? '')));
        fwrite(STDERR, "[article-generate] invalid output (body chars={$bodyLen}). Retrying…\n");
        usleep(random_int(150000, 450000));
    }
}

if (!$post) {
    fwrite(STDERR, "[article-generate] failed after ".MAX_RETRIES." attempts. Aborting.\n");
    exit(1);
}

// --- FINALIZE ASCII-ONLY SLUG, then save atomically ---
$rawForSlug   = $post['slug'] !== '' ? $post['slug'] : $post['title'];
$asciiSlug    = $slugifyAscii($rawForSlug, $lang);
if ($asciiSlug === '') {
    // Fallback to Util::slugify if our translit produced empty (extremely unlikely)
    $asciiSlug = Util::slugify($rawForSlug) ?: 'post';
}
$post['slug'] = $uniqueSlug($asciiSlug);

$json = json_encode($post, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE);

$path = $postsDir . '/' . $post['slug'] . '.json';
$atomicWrite($path, $json);
$ensurePerms($path, false, true); // post file -> 0775

// Update posts index AFTER the post is safely persisted
$index = ['posts' => []];
if (is_file($indexFile)) {
    $parsed = json_decode((string)file_get_contents($indexFile), true);
    if (is_array($parsed)) $index = $parsed;
}
$index['posts'] = array_values(array_filter(
    $index['posts'],
    fn($p) => ($p['slug'] ?? '') !== $post['slug']
));
array_unshift($index['posts'], [
    'title'        => $post['title'],
    'slug'         => $post['slug'],
    'summary'      => $post['summary'],
    'tags'         => $post['tags'],
    'published_at' => $post['published_at'],
]);

$atomicWrite($indexFile, json_encode($index, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE));
$ensurePerms($indexFile, false, true); // posts.json -> 0775

printf("Saved post: %s (%s)\n", $post['title'], $post['slug']);
